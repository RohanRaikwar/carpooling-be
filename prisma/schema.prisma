generator client {
  provider = "prisma-client-js" // âœ… required for Prisma v7
}

datasource db {
  provider = "postgresql"
}

// ENUMS
enum OnboardingStatus {
  PENDING
  COMPLETED
}

enum Salutation {
  MR
  MS
  MRS
  MX
  OTHER
}

enum Chattiness {
  LOW
  MEDIUM
  HIGH
}

enum PetsPreference {
  YES
  NO
  SOMETIMES
}

enum VehicleType {
  sedan
  hatchback
  suv
  minibus
  coupe
  convertible
  pickup
  van
  truck
}

enum DocumentType {
  VEHICLE_IMAGE
  VEHICLE_DOCUMENT
  DRIVING_LICENSE
  INSURANCE_DOCUMENT
}

model User {
  id String @id @default(uuid())

  name       String?     @db.VarChar(255)
  nickName   String?     @db.VarChar(255)
  salutation Salutation?
  dob        DateTime?

  email         String?  @unique
  phone         String?  @unique
  emailVerified Boolean  @default(false)
  phoneVerified Boolean  @default(false)

  avatarUrl String?

  onboardingStatus OnboardingStatus @default(PENDING)
  isVerified       Boolean          @default(false)

  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  travelPreference TravelPreference?
  vehicles         Vehicle[]
  refreshTokens    RefreshToken[]
  rides            Ride[]
  bookings         RideBooking[]     @relation("PassengerBookings")

  // Chat relations
  conversationsAsA Conversation[] @relation("ConversationUserA")
  conversationsAsB Conversation[] @relation("ConversationUserB")
  sentMessages     Message[]      @relation("MessageSender")
  receivedMessages Message[]      @relation("MessageReceiver")
  deviceTokens     DeviceToken[]

  // Notification relations
  notifications Notification[]

  @@index([id])
}

model TravelPreference {
  id String @id @default(uuid())

  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  chattiness Chattiness
  pets       PetsPreference

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([id])
}

model Vehicle {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  licenseCountry String
  licenseNumber  String

  brand      String?
  model_num  String?
  model_name String?
  type       VehicleType?
  color      String?
  year       Int?
  imageUrl     String?
  isVerified Boolean      @default(false)
  deletedAt  DateTime?

  documents VehicleDocument[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([userId, deletedAt])
}

model VehicleDocument {
  id           String       @id @default(uuid())
  vehicleId    String
  vehicle      Vehicle      @relation(fields: [vehicleId], references: [id], onDelete: Cascade)
  imageUrl     String
  documentType DocumentType

  createdAt DateTime @default(now())

  @@index([vehicleId])
}

model RefreshToken {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime
  revoked   Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([expiresAt])
}

// ============ RIDE ENUMS ============
enum RideStatus {
  DRAFT
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum WaypointType {
  PICKUP
  DROPOFF
  STOPOVER
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

// ============ CHAT ENUMS ============
enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

// ============ RIDE MODELS ============
model Ride {
  id String @id @default(uuid())

  driverId  String
  driver    User    @relation(fields: [driverId], references: [id], onDelete: Cascade)
  vehicleId String?

  // Origin details
  originPlaceId  String
  originAddress  String
  originLat      Float
  originLng      Float

  // Destination details
  destinationPlaceId  String
  destinationAddress  String
  destinationLat      Float
  destinationLng      Float

  // Encoded polyline for the selected route
  routePolyline        String?
  routeDistanceMeters  Int?
  routeDurationSeconds Int?

  // Schedule
  departureDate DateTime @db.Date
  departureTime String // HH:mm format

  // Capacity & Pricing
  totalSeats       Int
  availableSeats   Int
  basePricePerSeat Float
  currency         String @default("GBP")

  // Additional info
  notes String?

  status RideStatus @default(DRAFT)

  // Relations
  waypoints RideWaypoint[]
  bookings  RideBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([driverId])
  @@index([status])
  @@index([departureDate])
}

model RideWaypoint {
  id     String @id @default(uuid())
  rideId String
  ride   Ride   @relation(fields: [rideId], references: [id], onDelete: Cascade)

  placeId String
  address String
  lat     Float
  lng     Float

  // Type: PICKUP, DROPOFF, or STOPOVER
  waypointType WaypointType

  // Order of this waypoint in the route
  orderIndex Int

  // Optional custom price for this waypoint
  pricePerSeat Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([rideId])
}

model RideBooking {
  id          String @id @default(uuid())
  rideId      String
  ride        Ride   @relation(fields: [rideId], references: [id], onDelete: Cascade)
  passengerId String
  passenger   User   @relation("PassengerBookings", fields: [passengerId], references: [id], onDelete: Cascade)

  pickupWaypointId  String?
  dropoffWaypointId String?

  seatsBooked Int   @default(1)
  totalPrice  Float

  status BookingStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([rideId])
  @@index([passengerId])
}

// ============ CHAT MODELS ============
model Conversation {
  id String @id @default(uuid())

  // Normalized pair for 1:1 uniqueness (userAId < userBId lexicographically)
  userAId String
  userBId String
  userA   User   @relation("ConversationUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userB   User   @relation("ConversationUserB", fields: [userBId], references: [id], onDelete: Cascade)

  lastMsgAt      DateTime?
  lastMsgPreview String?

  messages Message[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userAId, userBId])
  @@index([userAId, lastMsgAt])
  @@index([userBId, lastMsgAt])
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  senderId       String
  receiverId     String

  type        MessageType @default(TEXT)
  text        String?
  payloadJson Json?
  clientMsgId String? // Idempotency key from client

  // Status timestamps
  deliveredAt DateTime?
  readAt      DateTime?

  createdAt DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver     User         @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, clientMsgId])
  @@index([conversationId, createdAt])
  @@index([receiverId, deliveredAt, createdAt])
}

model DeviceToken {
  id       String @id @default(uuid())
  userId   String
  platform String // ios / android
  token    String @unique

  createdAt  DateTime  @default(now())
  lastSeenAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Notification {
  id     String @id @default(uuid())
  userId String
  type   String // chat_message, booking_confirmed, ride_update, system, etc.
  title  String
  body   String
  data   Json?  // Additional structured data (e.g. rideId, bookingId, senderId)

  isRead Boolean   @default(false)
  readAt DateTime?

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, isRead])
}
